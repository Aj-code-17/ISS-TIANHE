<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ISS & Tiangong Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    .marker {
      background-size: cover;
      width: 40px; 
      height: 40px; 
      transform: translate(-50%, -50%); 
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/satellite.js@4.0.0/dist/satellite.min.js"></script>

  <script>
    // 1. TLE Data (User Provided - NOT CHANGED)
    const TLE = {
      ISS: {
        line1: '1 25544U 98067A   25332.93143523  .00009407  00000-0  17759-3 0  9997',
        line2: '2 25544  51.6312 210.8341 0003738 180.7008 179.3975 15.49177370540716'
      },
      TIANGONG: {
        line1: '1 48274U 21035A   25333.06763102  .00014333  00000-0  18674-3 0  9990',
        line2: '2 48274  41.4664  99.6574 0010668 290.8853  69.0842 15.58380651261895'
      }
    };

    // 2. Initialize MapLibre GL with Satellite Imagery Style
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        'version': 8,
        'sources': {
          'satellite-tiles': {
            'type': 'raster',
            'tiles': [
              'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            ],
            'tileSize': 256
          }
        },
        'layers': [
          {
            'id': 'satellite-background',
            'type': 'raster',
            'source': 'satellite-tiles',
            'minzoom': 0,
            'maxzoom': 22
          }
        ]
      },
      center: [0, 0],
      zoom: 1.5,
      interactive: true
    });

    // Function to create custom HTML element for markers
    function createMarkerElement(iconUrl) {
      const el = document.createElement('div');
      el.className = 'marker';
      el.style.backgroundImage = `url(${iconUrl})`;
      return el;
    }

    const issMarker = new maplibregl.Marker({ element: createMarkerElement('iss.png') })
      .setLngLat([0, 0]).addTo(map);
    const tiangongMarker = new maplibregl.Marker({ element: createMarkerElement('tiangong.png') })
      .setLngLat([0, 0]).addTo(map);

    // LIVE ISS tracking (using API) - This part remains mostly the same,
    // but we'll try to apply antimeridian handling to the marker's update.
    async function getISSLocation() {
      const resp = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
      const d = await resp.json();
      return [d.longitude, d.latitude];
    }

    // FIX: Antimeridian handling for marker movement
    function handleMarkerAntimeridian(marker, currentLngLat, newLngLat) {
        const [currentLng, currentLat] = currentLngLat;
        const [newLng, newLat] = newLngLat;

        // If the longitude difference is large, it might be crossing the antimeridian
        if (Math.abs(newLng - currentLng) > 180) {
            // Check if it's wrapping from +180 to -180 or vice-versa
            // If newLng is much smaller than currentLng, it means it wrapped from positive to negative
            if (newLng < currentLng && currentLng > 90 && newLng < -90) {
                // To prevent the line across the map, we'll set the marker to appear on the other side
                // This makes it visually "disappear" from one edge and "reappear" on the other.
                // We briefly move it off-screen (e.g., beyond -180 or +180) and then reset it.
                marker.setLngLat([(newLng > 0 ? -180 : 180), newLat]); // Instantly jump to the other edge
                // Then, set to the actual new position after a very short delay for smoother visual 'teleport'
                setTimeout(() => marker.setLngLat(newLngLat), 10);
            } 
            // If newLng is much larger than currentLng, it means it wrapped from negative to positive
            else if (newLng > currentLng && currentLng < -90 && newLng > 90) {
                 marker.setLngLat([(newLng > 0 ? -180 : 180), newLat]); // Instantly jump to the other edge
                 setTimeout(() => marker.setLngLat(newLngLat), 10);
            }
            else { // For other large jumps, just set it directly
                marker.setLngLat(newLngLat);
            }
        } else {
            marker.setLngLat(newLngLat);
        }
    }


    async function updateISS() {
      try {
        const newLoc = await getISSLocation();
        const currentLoc = issMarker.getLngLat().toArray();
        handleMarkerAntimeridian(issMarker, currentLoc, newLoc);
      } catch (e) {
        console.error('ISS fetch error', e);
      }
    }
    updateISS();
    setInterval(updateISS, 5000);

    // Load Satellite.js
    const satScript = document.createElement('script');
    satScript.src = 'https://cdn.jsdelivr.net/npm/satellite.js@4.0.0/dist/satellite.min.js';
    document.head.appendChild(satScript);

    let satReady = false, mapReady = false;
    satScript.onload = () => { satReady = true; tryDraw(); };
    map.on('load', () => { mapReady = true; tryDraw(); });

    // --- Utility Functions ---

    function normalizeLng(lng) {
      return ((lng + 180) % 360 + 360) % 360 - 180;
    }
    
    function getSatellitePosition(tleLine1, tleLine2, date) {
        const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
        const positionAndVelocity = satellite.propagate(satrec, date);
        
        if (!positionAndVelocity.position) return null;

        const positionGd = satellite.eciToGeodetic(positionAndVelocity.position, satellite.gstime(date));
        
        const longitude = normalizeLng(satellite.degreesLong(positionGd.longitude));
        const latitude = satellite.degreesLat(positionGd.latitude);
        
        return [longitude, latitude];
    }

    // Splits a line into segments if it crosses the antimeridian
    function splitForAntimeridian(coords) {
      if (!coords.length) return [];
      const segments = [];
      let current = [ coords[0] ];
      for (let i = 1; i < coords.length; i++) {
        const prev = coords[i - 1];
        let cur = coords[i];
        const d = Math.abs(cur[0] - prev[0]);
        if (d > 180) {
          segments.push(current);
          const wrappedLng = cur[0] > prev[0] ? cur[0] - 360 : cur[0] + 360;
          current = [ [wrappedLng, cur[1]] ];
        } else {
          current.push(cur);
        }
      }
      segments.push(current);
      return segments;
    }

    function computeOrbit(tle1, tle2, minutes = 90) {
      const coordinates = [];
      const now = new Date();
      for (let i = 0; i <= minutes; i++) {
        const t = new Date(now.getTime() + i * 60 * 1000);
        const pos = getSatellitePosition(tle1, tle2, t);
        if (pos) {
          coordinates.push(pos);
        }
      }
      return coordinates;
    }

    // --- End Utility Functions ---

    function tryDraw() {
      if (!satReady || !mapReady) return;
      drawOrbits();
      updateSatellitePositions(); 
    }

    // Draws line segments, handling the antimeridian crossing
    function drawWrappedLine(idBase, coords, color) {
      // Clean up old layers/sources
      for (let i = 0; i < 5; i++) {
        const sourceId = `${idBase}_${i}`;
        const layerId = `${idBase}_${i}`;
        if (map.getLayer(layerId)) { map.removeLayer(layerId); }
        if (map.getSource(sourceId)) { map.removeSource(sourceId); }
      }

      const segs = splitForAntimeridian(coords);
      segs.forEach((seg, idx) => {
        const sourceId = `${idBase}_${idx}`;
        const layerId = `${idBase}_${idx}`;

        map.addSource(sourceId, {
          type: 'geojson',
          data: { type: 'Feature', geometry: { type: 'LineString', coordinates: seg } }
        });
        map.addLayer({
          id: layerId,
          type: 'line',
          source: sourceId,
          layout: {},
          paint: {
            'line-color': color,
            'line-width': 2,
            'line-dasharray': [4, 4]
          }
        });
      });
    }

    function drawOrbits() {
      // Use helper variables to reference the TLEs
      const issT1 = TLE.ISS.line1;
      const issT2 = TLE.ISS.line2;
      const tianheT1 = TLE.TIANGONG.line1;
      const tianheT2 = TLE.TIANGONG.line2;

      const issCoords = computeOrbit(issT1, issT2);
      const tgCoords = computeOrbit(tianheT1, tianheT2);

      drawWrappedLine('issOrbit', issCoords, 'red');
      drawWrappedLine('tianheOrbit', tgCoords, 'blue');

      console.log('ISS orbit points:', issCoords.length, 'Tiangong orbit points:', tgCoords.length);

      // Start the interval to update the predicted path every minute
      setInterval(() => {
          const issNewCoords = computeOrbit(issT1, issT2);
          drawWrappedLine('issOrbit', issNewCoords, 'red');

          const tgNewCoords = computeOrbit(tianheT1, tianheT2);
          drawWrappedLine('tianheOrbit', tgNewCoords, 'blue');

          console.log('Orbits refreshed');
      }, 60000); // Refresh orbit path every 60 seconds
    }
    
    // Function to update the live Tiangong marker
    function updateSatellitePositions() {
        setInterval(() => {
            const now = new Date();
            
            // --- Update Tiangong ---
            const tiangongPos = getSatellitePosition(TLE.TIANGONG.line1, TLE.TIANGONG.line2, now);
            if (tiangongPos) {
                const currentTiangongLoc = tiangongMarker.getLngLat().toArray();
                handleMarkerAntimeridian(tiangongMarker, currentTiangongLoc, tiangongPos);
            }
        }, 1000); // Update position every 1 second for smooth movement
    }
    
  </script>
</body>
</html>
