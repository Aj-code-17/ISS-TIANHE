<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ISS & Tiangong Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css" />
  <style>
    body { margin: 0; padding: 0; height: auto; }
    #map { position: relative; height: 100vh; width: 100%; }
    .marker {
      background-size: cover;
      width: 40px;
      height: 40px;
      transform: translate(-50%, -50%);
    }
    /* Added styles for info panels (visible on scroll down) */
    .info-section {
      padding: 20px;
      background-color: #2f2f2f;
      color: #fff;
      display: flex;
      justify-content: space-around;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <!-- Added info section below map; updates live; scroll down to view -->
  <div class="info-section">
    <div class="orbital-data">
      <h4>ISS Orbital Data</h4>
      <p>Position-Time (GMT/UTC+5): <span id="iss-time"></span></p>
      <p>Speed: <span id="iss-speed"></span> km/h</p>
      <p>Altitude: <span id="iss-altitude"></span> km</p>
      <p>Latitude: <span id="iss-lat"></span></p>
      <p>Longitude: <span id="iss-lon"></span></p>
      <p>Distance Loc.: <span id="iss-distance"></span> km</p>
      <p>The current Earth orbital period is: <span id="iss-period"></span></p>
      <p>Your Location: <span id="user-location-iss"></span></p> <!-- Added user location display -->
    </div>
    <div class="orbital-data">
      <h4>Tiangong Orbital Data</h4>
      <p>Position-Time (GMT/UTC+5): <span id="tg-time"></span></p>
      <p>Speed: <span id="tg-speed"></span> km/h</p>
      <p>Altitude: <span id="tg-altitude"></span> km</p>
      <p>Latitude: <span id="tg-lat"></span></p>
      <p>Longitude: <span id="tg-lon"></span></p>
      <p>Distance Loc.: <span id="tg-distance"></span> km</p>
      <p>The current Earth orbital period is: <span id="tg-period"></span></p>
      <p>Your Location: <span id="user-location-tg"></span></p> <!-- Added user location display -->
    </div>
  </div>
  <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/satellite.js@4.0.0/dist/satellite.min.js"></script>
  <script>
    // 1. TLE Data (User Provided - NOT CHANGED)
    const TLE = {
      ISS: {
        line1: '1 25544U 98067A   25332.93143523  .00009407  00000+0  17759-3 0  9996',
        line2: '2 25544  51.6312 210.8341 0003738 180.7008 179.3975 15.49177370540716'
      },
      TIANGONG: {
        line1: '1 48274U 21035A   25333.06763102  .00014333  00000+0  18674-3 0  9999',
        line2: '2 48274  41.4664  99.6574 0010668 290.8853  69.0842 15.58380651261895'
      }
    };
    // 2. Initialize MapLibre GL with Satellite Imagery Style
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        'version': 8,
        'sources': {
          'satellite-tiles': {
            'type': 'raster',
            'tiles': [
              'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            ],
            'tileSize': 256
          }
        },
        'layers': [
          {
            'id': 'satellite-background',
            'type': 'raster',
            'source': 'satellite-tiles',
            'minzoom': 0,
            'maxzoom': 22
          }
        ]
      },
      center: [0, 0],
      zoom: 1.5,
      interactive: true,
      renderWorldCopies: true
    });
    // Function to create custom HTML element for markers
    function createMarkerElement(iconUrl) {
      const el = document.createElement('div');
      el.className = 'marker';
      el.style.backgroundImage = `url(${iconUrl})`;
      return el;
    }
    const issMarker = new maplibregl.Marker({ element: createMarkerElement('iss.png') })
      .setLngLat([0, 0]).addTo(map);
    const tiangongMarker = new maplibregl.Marker({ element: createMarkerElement('tiangong.png') })
      .setLngLat([0, 0]).addTo(map);
    // FIXED: Simplified marker update to use normalized positions, allowing jump (disappear on right, appear on left)
    function updateMarker(marker, newLngLat) {
        marker.setLngLat(newLngLat);
    }
    // Get user's location for distance calculation and marking on map (with permission)
    let userLat, userLon, userCity = 'N/A';
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(async pos => {
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        // Reverse geocode to get city name
        try {
          const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${userLat}&lon=${userLon}&zoom=10&addressdetails=1`);
          const data = await response.json();
          userCity = data.address.city || data.address.town || data.address.village || 'Unknown Location';
        } catch (e) {
          console.error('Reverse geocode error', e);
          userCity = 'Unknown Location';
        }
        // Update user location displays
        document.getElementById('user-location-iss').innerText = userCity;
        document.getElementById('user-location-tg').innerText = userCity;
        // Add user marker with city name above it, styled as a standard map pin
        function createUserMarkerElement(city) {
          const el = document.createElement('div');
          el.style.textAlign = 'center';
          const label = document.createElement('div');
          label.textContent = city;
          label.style.background = 'white';
          label.style.color = 'black';
          label.style.padding = '2px';
          label.style.borderRadius = '3px';
          label.style.whiteSpace = 'nowrap';
          const pin = document.createElement('img');
          pin.src = 'https://maps.google.com/mapfiles/ms/icons/red-pushpin.png';
          pin.style.width = '32px';
          pin.style.height = '48px';
          pin.style.display = 'block';
          pin.style.margin = 'auto';
          el.appendChild(label);
          el.appendChild(pin);
          return el;
        }
        const userMarker = new maplibregl.Marker({
          element: createUserMarkerElement(userCity),
          anchor: 'bottom'  // Anchor the bottom center of the element (pin tip) to the precise location
        }).setLngLat([userLon, userLat]).addTo(map);
      }, err => {
        console.error('Geolocation error', err);
        // Update displays to N/A if denied
        document.getElementById('user-location-iss').innerText = userCity;
        document.getElementById('user-location-tg').innerText = userCity;
      });
    }
    // Haversine formula for distance
    const degToRad = deg => deg * Math.PI / 180;
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = degToRad(lat2 - lat1);
      const dLon = degToRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(degToRad(lat1)) * Math.cos(degToRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }
    // LIVE ISS tracking (using API) with data updates
    async function updateISS() {
      try {
        const resp = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
        const d = await resp.json();
        updateMarker(issMarker, [d.longitude, d.latitude]);
        // Update display data
        const lat = d.latitude;
        const lon = d.longitude;
        const latStr = `${Math.abs(lat).toFixed(2)} ${lat < 0 ? 'South' : 'North'}`;
        const lonStr = `${Math.abs(lon).toFixed(2)} ${lon < 0 ? 'West' : 'East'}`;
        // Time in UTC+5
        const date = new Date(d.timestamp * 1000);
        let hours = date.getUTCHours() + 5;
        let carryDays = 0;
        if (hours >= 24) {
          hours -= 24;
          carryDays = 1;
        }
        const tempDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() + carryDays);
        const day = tempDate.getUTCDate();
        const monthIndex = tempDate.getUTCMonth();
        const year = tempDate.getUTCFullYear();
        const month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
        const mins = String(date.getUTCMinutes()).padStart(2, '0');
        const secs = String(date.getUTCSeconds()).padStart(2, '0');
        const timeStr = `${day}. ${month}. ${year}, ${String(hours).padStart(2, '0')}:${mins}:${secs}`;
        document.getElementById('iss-time').innerText = timeStr;
        document.getElementById('iss-speed').innerText = d.velocity.toFixed(2);
        document.getElementById('iss-altitude').innerText = d.altitude.toFixed(2);
        document.getElementById('iss-lat').innerText = latStr;
        document.getElementById('iss-lon').innerText = lonStr;
        let distStr = 'N/A';
        if (typeof userLat !== 'undefined') {
          const dist = haversine(lat, lon, userLat, userLon);
          distStr = dist.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }
        document.getElementById('iss-distance').innerText = distStr;
        // Orbital period
        const GM = 3.986004418e5;
        const a = 6371 + d.altitude;
        const period_sec = 2 * Math.PI * Math.sqrt(a ** 3 / GM);
        const min = Math.floor(period_sec / 60);
        const sec = Math.round(period_sec % 60);
        const meanMotion = parseFloat(TLE.ISS.line2.split(/\s+/)[7]);
        const period_avg = 1440 / meanMotion;
        const min_avg = Math.floor(period_avg);
        const sec_avg = Math.round((period_avg - min_avg) * 60);
        const periodStr = `${min} m ${String(sec).padStart(2, '0')} s (on average ∅: ${min_avg} m ${String(sec_avg).padStart(2, '0')} s | ${meanMotion} orbits per day)`;
        document.getElementById('iss-period').innerText = periodStr;
      } catch (e) {
        console.error('ISS fetch error', e);
      }
    }
    updateISS();
    setInterval(updateISS, 5000);
    // Load Satellite.js
    const satScript = document.createElement('script');
    satScript.src = 'https://cdn.jsdelivr.net/npm/satellite.js@4.0.0/dist/satellite.min.js';
    document.head.appendChild(satScript);
    let satReady = false, mapReady = false;
    satScript.onload = () => { satReady = true; tryDraw(); };
    map.on('load', () => { mapReady = true; tryDraw(); });
    // TLE Utility Functions
    function normalizeLng(lng) {
      return ((lng + 180) % 360 + 360) % 360 - 180;
    }
    function getSatellitePosition(tleLine1, tleLine2, date) {
        const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
        const positionAndVelocity = satellite.propagate(satrec, date);
        if (!positionAndVelocity.position) return null;
        const positionGd = satellite.eciToGeodetic(positionAndVelocity.position, satellite.gstime(date));
        const longitude = normalizeLng(satellite.degreesLong(positionGd.longitude));
        const latitude = satellite.degreesLat(positionGd.latitude);
        const altitude = positionGd.height;
        const velocity_km_s = Math.sqrt(positionAndVelocity.velocity.x ** 2 + positionAndVelocity.velocity.y ** 2 + positionAndVelocity.velocity.z ** 2);
        const velocity = velocity_km_s * 3600;
        return { longitude, latitude, altitude, velocity, timestamp: date.getTime() / 1000 };
    }
    // splitForAntimeridian and computeOrbit remain the same
    function splitForAntimeridian(coords) {
      if (!coords.length) return [];
      const segments = [];
      let current = [coords[0]];
      for (let i = 1; i < coords.length; i++) {
        const prev = coords[i - 1];
        const cur = coords[i];
        const diff = cur[0] - prev[0];
        if (Math.abs(diff) <= 180) {
          current.push(cur);
        } else {
          let boundary, unwrappedDiff;
          if (diff > 180) {
            unwrappedDiff = diff - 360;
            boundary = -180;
          } else {
            unwrappedDiff = diff + 360;
            boundary = 180;
          }
          const t = (boundary - prev[0]) / unwrappedDiff;
          const intersectLat = prev[1] + t * (cur[1] - prev[1]);
          current.push([boundary, intersectLat]);
          segments.push(current);
          const nextBoundary = -boundary;
          current = [[nextBoundary, intersectLat], cur];
        }
      }
      segments.push(current);
      return segments;
    }
    function computeOrbit(tle1, tle2, minutes = 90) {
      const coordinates = [];
      const now = new Date();
      for (let i = 0; i <= minutes; i++) {
        const t = new Date(now.getTime() + i * 60 * 1000);
        const pos = getSatellitePosition(tle1, tle2, t);
        if (pos) {
          coordinates.push([pos.longitude, pos.latitude]);
        }
      }
      return coordinates;
    }
    function tryDraw() {
      if (!satReady || !mapReady) return;
      drawOrbits();
      updateSatellitePositions();
    }
    function drawWrappedLine(idBase, coords, color) {
      for (let i = 0; i < 5; i++) {
        const sourceId = `${idBase}_${i}`;
        const layerId = `${idBase}_${i}`;
        if (map.getLayer(layerId)) { map.removeLayer(layerId); }
        if (map.getSource(sourceId)) { map.removeSource(sourceId); }
      }
      const segs = splitForAntimeridian(coords);
      segs.forEach((seg, idx) => {
        const sourceId = `${idBase}_${idx}`;
        const layerId = `${idBase}_${idx}`;
        map.addSource(sourceId, {
          type: 'geojson',
          data: { type: 'Feature', geometry: { type: 'LineString', coordinates: seg } }
        });
        map.addLayer({
          id: layerId,
          type: 'line',
          source: sourceId,
          layout: {},
          paint: {
            'line-color': color,
            'line-width': 2
          }
        });
      });
    }
    function drawOrbits() {
      const issT1 = TLE.ISS.line1;
      const issT2 = TLE.ISS.line2;
      const tianheT1 = TLE.TIANGONG.line1;
      const tianheT2 = TLE.TIANGONG.line2;
      const issCoords = computeOrbit(issT1, issT2);
      const tgCoords = computeOrbit(tianheT1, tianheT2);
      drawWrappedLine('issOrbit', issCoords, 'red');
      drawWrappedLine('tianheOrbit', tgCoords, 'blue');
      setInterval(() => {
          const issNewCoords = computeOrbit(issT1, issT2);
          drawWrappedLine('issOrbit', issNewCoords, 'red');
          const tgNewCoords = computeOrbit(tianheT1, tianheT2);
          drawWrappedLine('tianheOrbit', tgNewCoords, 'blue');
      }, 60000);
    }
    // Update Tiangong with data updates
    function updateSatellitePositions() {
        setInterval(() => {
            const now = new Date();
            const tiangongPos = getSatellitePosition(TLE.TIANGONG.line1, TLE.TIANGONG.line2, now);
            if (tiangongPos) {
                updateMarker(tiangongMarker, [tiangongPos.longitude, tiangongPos.latitude]);
                // Update display data (similar to ISS)
                const lat = tiangongPos.latitude;
                const lon = tiangongPos.longitude;
                const latStr = `${Math.abs(lat).toFixed(2)} ${lat < 0 ? 'South' : 'North'}`;
                const lonStr = `${Math.abs(lon).toFixed(2)} ${lon < 0 ? 'West' : 'East'}`;
                // Time in UTC+5
                const date = new Date(tiangongPos.timestamp * 1000);
                let hours = date.getUTCHours() + 5;
                let carryDays = 0;
                if (hours >= 24) {
                  hours -= 24;
                  carryDays = 1;
                }
                const tempDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() + carryDays);
                const day = tempDate.getUTCDate();
                const monthIndex = tempDate.getUTCMonth();
                const year = tempDate.getUTCFullYear();
                const month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                const mins = String(date.getUTCMinutes()).padStart(2, '0');
                const secs = String(date.getUTCSeconds()).padStart(2, '0');
                const timeStr = `${day}. ${month}. ${year}, ${String(hours).padStart(2, '0')}:${mins}:${secs}`;
                document.getElementById('tg-time').innerText = timeStr;
                document.getElementById('tg-speed').innerText = tiangongPos.velocity.toFixed(2);
                document.getElementById('tg-altitude').innerText = tiangongPos.altitude.toFixed(2);
                document.getElementById('tg-lat').innerText = latStr;
                document.getElementById('tg-lon').innerText = lonStr;
                let distStr = 'N/A';
                if (typeof userLat !== 'undefined') {
                  const dist = haversine(lat, lon, userLat, userLon);
                  distStr = dist.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                }
                document.getElementById('tg-distance').innerText = distStr;
                // Orbital period
                const GM = 3.986004418e5;
                const a = 6371 + tiangongPos.altitude;
                const period_sec = 2 * Math.PI * Math.sqrt(a ** 3 / GM);
                const min = Math.floor(period_sec / 60);
                const sec = Math.round(period_sec % 60);
                const meanMotion = parseFloat(TLE.TIANGONG.line2.split(/\s+/)[7]);
                const period_avg = 1440 / meanMotion;
                const min_avg = Math.floor(period_avg);
                const sec_avg = Math.round((period_avg - min_avg) * 60);
                const periodStr = `${min} m ${String(sec).padStart(2, '0')} s (on average ∅: ${min_avg} m ${String(sec_avg).padStart(2, '0')} s | ${meanMotion} orbits per day)`;
                document.getElementById('tg-period').innerText = periodStr;
            }
        }, 1000);
    }
  </script>
</body>
</html>
